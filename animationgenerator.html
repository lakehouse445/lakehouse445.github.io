<!DOCTYPE html>
<html>
<head>
    <title>Simple Wavy Text with Editor & Exporter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column; /* Stack editor and canvas vertically */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1a1a; /* Darker background */
            font-family: monospace;
            color: white;
            padding: 20px;
            box-sizing: border-box;
        }
        canvas {
            background-color: #000;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(76, 29, 149, 0.5);
            max-width: 100%; /* Ensure canvas doesn't overflow */
            max-height: 50vh;
        }
        #main-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        #editor {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px 20px;
            align-items: center;
        }
        #editor label { justify-self: end; }
        #editor input, #editor input[type="file"] {
            background-color: #444;
            border: 1px solid #666;
            color: white;
            padding: 5px;
            border-radius: 4px;
            width: 200px;
        }
        #export-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            grid-column: 1 / -1; /* Span both columns */
            justify-content: center;
        }
        #export-controls button {
            background-color: #4f46e5;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
        }
        #export-controls button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #status, #debug-options {
            grid-column: 1 / -1;
            text-align: center;
            font-size: 0.9em;
            color: #ccc;
        }
        #debug-options {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        #debug-options input {
           width: auto;
        }
        /* Info Button & Modal */
        #info-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #4a5568;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #info-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #info-modal-content {
            background-color: #2d2d2d;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            color: #eee;
        }
        #info-modal-content h2 {
            margin-top: 0;
            color: white;
        }
        #info-modal-content code {
            background-color: #444;
            padding: 2px 5px;
            border-radius: 3px;
        }
        #info-modal-content ol {
            padding-left: 20px;
        }
        #info-modal-content li {
            margin-bottom: 10px;
        }
        /* FIX: Added this style to hide the modal */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <button id="info-button">?</button>

    <div id="info-modal" class="hidden">
        <div id="info-modal-content">
            <h2>How to Use This Tool</h2>
            <p>This tool creates a "wavy rainbow text" animation and allows you to export it.</p>
            <p>Made by lakehouse circa 2025.</p>
            <p>Based on https://codepen.io/adelciotto/pen/bePLZE</p>
            <ol>
                <li>Adjust the animation settings in the editor to get the look you want.</li>
                <li>Click a "Capture" button to generate the animation frames. This will download a <code>.zip</code> file.</li>
                <li>Unzip the downloaded file into a new folder.</li>
                <li><strong>IMPORTANT:</strong> Copy your <code>ffmpeg.exe</code> file into that same folder.</li>
                <li>Double-click the <code>create_video.bat</code> file inside the folder to create the final <code>.mp4</code> video.</li>
            </ol>
            <button id="close-modal-button">Close</button>
        </div>
    </div>


    <div id="main-container">
        <!-- Editor UI -->
        <div id="editor">
            <label for="textInput">Text:</label>
            <input type="text" id="textInput" value="Lakehouse">

            <label for="fontUpload">Font:</label>
            <input type="file" id="fontUpload" accept=".ttf,.otf,.woff">

            <label for="amplitudeInput">Amplitude:</label>
            <input type="number" id="amplitudeInput" value="5">

            <label for="waveSpeedInput">Wave Speed:</label>
            <input type="number" id="waveSpeedInput" value="250">
            
            <label for="fontSizeInput">Font Size:</label>
            <input type="number" id="fontSizeInput" value="55">

            <label for="widthInput">Width:</label>
            <input type="number" id="widthInput" value="3840">

            <label for="heightInput">Height:</label>
            <input type="number" id="heightInput" value="2160">
            
            <div id="export-controls">
                <button id="capture5s">Capture 5s</button>
                <button id="capture10s">Capture 10s</button>
                <button id="capture15s">Capture 15s</button>
            </div>

            <div id="debug-options">
                <input type="checkbox" id="upscaleCheckbox">
                <label for="upscaleCheckbox">Upscale 2x on Capture</label>
            </div>
            
            <div id="status">Ready</div>
        </div>

        <!-- Canvas will be created here by script -->
    </div>

<script>
    // --- Configuration (now mutable) ---
    let config = {
        width: 3840,
        height: 2160,
        amplitude: 5,
        waveSpeed: 250,
        textToAnimate: 'Lakehouse',
        fontSize: 55,
        fontFamily: 'Courier New'
    };

    // --- DOM Elements ---
    const textInput = document.getElementById('textInput');
    const fontUpload = document.getElementById('fontUpload');
    const amplitudeInput = document.getElementById('amplitudeInput');
    const waveSpeedInput = document.getElementById('waveSpeedInput');
    const fontSizeInput = document.getElementById('fontSizeInput');
    const widthInput = document.getElementById('widthInput');
    const heightInput = document.getElementById('heightInput');
    const upscaleCheckbox = document.getElementById('upscaleCheckbox');
    const statusDiv = document.getElementById('status');
    const infoButton = document.getElementById('info-button');
    const infoModal = document.getElementById('info-modal');
    const closeModalButton = document.getElementById('close-modal-button');
    const captureButtons = [
        document.getElementById('capture5s'),
        document.getElementById('capture10s'),
        document.getElementById('capture15s')
    ];


    // --- State Variables ---
    let canvas, ctx;
    let charObjs;
    let startTime = 0;
    let isCapturing = false;
    let customFontURL = '';

    /**
     * Updates the config object from the UI and re-initializes the text.
     */
    const updateFromEditor = () => {
        if (isCapturing) return;
        config.textToAnimate = textInput.value || ' ';
        config.amplitude = parseInt(amplitudeInput.value, 10);
        config.waveSpeed = parseInt(waveSpeedInput.value, 10);
        config.fontSize = parseInt(fontSizeInput.value, 10);
        config.width = parseInt(widthInput.value, 10);
        config.height = parseInt(heightInput.value, 10);
        
        canvas.width = config.width;
        canvas.height = config.height;
        initText(config);
    };

    /**
     * Creates an array of character objects for drawing.
     * @param {object} currentConfig - The configuration object to use for calculation.
     */
    const initText = (currentConfig) => {
        const fontStyle = `bold ${currentConfig.fontSize}px ${currentConfig.fontFamily}`;
        ctx.font = fontStyle;
        ctx.textBaseline = 'middle';
        const totalTextWidth = ctx.measureText(currentConfig.textToAnimate).width;
        let currentPosition = (currentConfig.width - totalTextWidth) / 2;
        charObjs = currentConfig.textToAnimate.split('').map((char, index) => {
            const charWidth = ctx.measureText(char).width;
            const charObj = { char, width: charWidth, position: currentPosition, index: index };
            currentPosition += charWidth;
            return charObj;
        });
    };
    
    /**
     * Draws a single frame of the animation at a specific time.
     * @param {number} time - The timestamp for the current frame.
     * @param {object} currentConfig - The configuration object to use for drawing.
     * @param {boolean} disableAntiAliasing - Flag to turn off smoothing.
     */
    const drawFrameAtTime = (time, currentConfig, disableAntiAliasing = false) => {
        ctx.imageSmoothingEnabled = !disableAntiAliasing;
        ctx.clearRect(0, 0, currentConfig.width, currentConfig.height);
        ctx.fillStyle = 'black';
        ctx.fillRect(0,0, currentConfig.width, currentConfig.height);

        const fontStyle = `bold ${currentConfig.fontSize}px ${currentConfig.fontFamily}`;
        ctx.font = fontStyle;
        ctx.textBaseline = 'middle';

        charObjs.forEach((charObj) => {
            const y = Math.sin(time / currentConfig.waveSpeed + charObj.index / 2.5) * currentConfig.amplitude;
            const normalizedY = (y + currentConfig.amplitude) / (currentConfig.amplitude * 2);
            const hue = normalizedY * 240;
            ctx.fillStyle = `hsl(${hue}, 100%, 60%)`;
            ctx.fillText(charObj.char, charObj.position, currentConfig.height / 2 + y);
        });
    }

    /**
     * The main animation loop for the live preview.
     */
    const animate = () => {
        if (!isCapturing) {
           drawFrameAtTime(Date.now() - startTime, config, false);
        }
        requestAnimationFrame(animate);
    };
    
    /**
     * Handles font file upload.
     */
    const handleFontUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            if (customFontURL) URL.revokeObjectURL(customFontURL);
            
            const fontFace = new FontFace('user-uploaded-font', event.target.result);
            document.fonts.add(fontFace);
            fontFace.load().then(() => {
                config.fontFamily = 'user-uploaded-font';
                updateFromEditor(); // Redraw with the new font
            }).catch(console.error);
        };
        reader.readAsArrayBuffer(file);
    };

    /**
     * Captures frames and packages them into a ZIP file.
     */
    const startCapture = async (durationSeconds) => {
        if (isCapturing) return;
        isCapturing = true;
        captureButtons.forEach(b => b.disabled = true);
        
        const originalConfig = { ...config };
        let captureConfig = { ...config };
        const scaleFactor = upscaleCheckbox.checked ? 2 : 1;
        
        if (scaleFactor > 1) {
            statusDiv.textContent = 'Scaling config for capture...';
            captureConfig.width *= scaleFactor;
            captureConfig.height *= scaleFactor;
            captureConfig.fontSize *= scaleFactor;
            captureConfig.amplitude *= scaleFactor;
            canvas.width = captureConfig.width;
            canvas.height = captureConfig.height;
            initText(captureConfig);
        }

        const frameRate = 120;
        const totalFrames = durationSeconds * frameRate;
        const zip = new JSZip();

        statusDiv.textContent = 'Starting capture...';

        try {
            for (let i = 0; i < totalFrames; i++) {
                const time = i * (1000 / frameRate);
                drawFrameAtTime(time, captureConfig, true); 
                
                const frameName = `frame_${String(i).padStart(4, '0')}.png`;
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                zip.file(frameName, blob);

                statusDiv.textContent = `Captured frame ${i + 1} of ${totalFrames}`;
                if (i % 10 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            statusDiv.textContent = 'Creating FFmpeg batch file...';
            const batContent = `@echo off\r\ncd /d "%~dp0"\r\nffmpeg -framerate ${frameRate} -i frame_%%04d.png -c:v libx264 -pix_fmt yuv420p -r ${frameRate} output.mp4\r\npause`;
            zip.file('create_video.bat', batContent);

            statusDiv.textContent = 'Generating ZIP file...';
            const zipBlob = await zip.generateAsync({type: 'blob'});

            statusDiv.textContent = 'Downloading...';
            const link = document.createElement('a');
            link.href = URL.createObjectURL(zipBlob);
            link.download = `wavy_text_capture.zip`;
            link.click();
            URL.revokeObjectURL(link.href);
            
        } finally {
            // Restore original settings for live preview
            if (scaleFactor > 1) {
                statusDiv.textContent = 'Restoring preview...';
                canvas.width = originalConfig.width;
                canvas.height = originalConfig.height;
                initText(originalConfig);
            }
            statusDiv.textContent = 'Ready';
            isCapturing = false;
            captureButtons.forEach(b => b.disabled = false);
        }
    };

    /**
     * Initializes the canvas and starts the application.
     */
    const start = () => {
        canvas = document.createElement('canvas');
        document.getElementById('main-container').appendChild(canvas);
        ctx = canvas.getContext('2d');
        updateFromEditor();

        const allInputs = document.querySelectorAll('#editor input[type="text"], #editor input[type="number"]');
        allInputs.forEach(input => input.addEventListener('input', updateFromEditor));
        fontUpload.addEventListener('change', handleFontUpload);

        infoButton.addEventListener('click', () => infoModal.classList.remove('hidden'));
        closeModalButton.addEventListener('click', () => infoModal.classList.add('hidden'));
        
        captureButtons[0].addEventListener('click', () => startCapture(5));
        captureButtons[1].addEventListener('click', () => startCapture(10));
        captureButtons[2].addEventListener('click', () => startCapture(15));
        
        startTime = Date.now();
        animate();
    };

    // Let's go!
    start();
</script>
</body>
</html>
