<!DOCTYPE html>
<html>
<head>
    <title>Wavy Text Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1a1a;
            font-family: monospace;
            color: white;
            padding: 20px;
            box-sizing: border-box;
        }
        canvas {
            background-color: #000;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(76, 29, 149, 0.5);
            max-width: 100%;
            max-height: 50vh;
        }
        #main-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        #editor {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px 20px;
            align-items: center;
        }
        #editor label { justify-self: end; }
        #editor input, #editor input[type="file"], #editor input[type="range"] {
            background-color: #444;
            border: 1px solid #666;
            color: white;
            padding: 5px;
            border-radius: 4px;
            width: 200px;
        }
        #editor input[type="range"] { padding: 0; }
        #export-controls {
            grid-column: 1 / -1;
            text-align: center;
        }
        #export-controls button {
            background-color: #4f46e5;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
        }
        #export-controls button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #status, #debug-options, #subtitle-toggle {
            grid-column: 1 / -1;
            text-align: center;
            font-size: 0.9em;
            color: #ccc;
        }
        #debug-options, #subtitle-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        #debug-options input, #subtitle-toggle input { width: auto; }
        #subtitle-settings {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px 20px;
            align-items: center;
            border-top: 1px solid #444;
            margin-top: 10px;
            padding-top: 10px;
        }
        .hidden { display: none !important; }
        #info-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #4a5568;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #info-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #info-modal-content {
            background-color: #2d2d2d;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            color: #eee;
        }
        #info-modal-content h2 { margin-top: 0; color: white; }
        #info-modal-content code { background-color: #444; padding: 2px 5px; border-radius: 3px; }
        #info-modal-content ol { padding-left: 20px; }
        #info-modal-content li { margin-bottom: 10px; }
    </style>
</head>
<body>
    <button id="info-button">?</button>
    <div id="info-modal" class="hidden">
        <div id="info-modal-content">
            <h2>How to Use This Tool</h2>
            <ol>
                <li>Adjust settings in the editor.</li>
                <li>Click "Start Capture" to generate a <code>.zip</code> file of animation frames.</li>
                <li>Unzip the downloaded file into a new folder.</li>
                <li><strong>IMPORTANT:</strong> Copy your <code>ffmpeg.exe</code> file into that same folder.</li>
                <li>Double-click the <code>create_video.bat</code> file to create the final <code>.mp4</code> video.</li>
            </ol>
            <button id="close-modal-button">Close</button>
        </div>
    </div>

    <div id="main-container">
        <div id="editor">
            <label for="textInput">Text:</label>
            <input type="text" id="textInput" value="New text">
            <label for="fontUpload">Font:</label>
            <input type="file" id="fontUpload" accept=".ttf,.otf,.woff">
            <label for="amplitudeInput">Amplitude:</label>
            <input type="number" id="amplitudeInput" value="5">
            <label for="waveSpeedInput">Wave Speed:</label>
            <input type="number" id="waveSpeedInput" value="250">
            <label for="fontSizeInput">Font Size:</label>
            <input type="number" id="fontSizeInput" value="55">
            <label for="kerningInput">Letter Spacing:</label>
            <input type="number" id="kerningInput" value="10">
            <label for="widthInput">Width:</label>
            <input type="number" id="widthInput" value="1920">
            <label for="heightInput">Height:</label>
            <input type="number" id="heightInput" value="1080">

            <div id="subtitle-toggle">
                <input type="checkbox" id="subtitleCheckbox">
                <label for="subtitleCheckbox">Show Subtitle</label>
            </div>
            <div id="subtitle-settings" class="hidden">
                <label for="subtitleTextInput">Subtitle Text:</label>
                <input type="text" id="subtitleTextInput" value="Subtitle text">
                <label for="subtitleFontSizeInput">Subtitle Font Size:</label>
                <input type="number" id="subtitleFontSizeInput" value="30">
                 <label for="subtitleYOffsetInput">Subtitle Y-Offset:</label>
                <input type="number" id="subtitleYOffsetInput" value="100">
                <label for="subtitleFadeInDelayInput">Fade-In Delay (s):</label>
                <input type="range" id="subtitleFadeInDelayInput" min="0" max="15" step="0.1" value="1">
                <span id="subtitleFadeInDelayValue" style="justify-self: start;">1.0s</span>
                <label for="subtitleFadeDurationInput">Fade Length (s):</label>
                <input type="range" id="subtitleFadeDurationInput" min="0.1" max="5" step="0.1" value="1">
                <span id="subtitleFadeDurationValue" style="justify-self: start;">1.0s</span>
            </div>

            <div id="export-controls">
                <label for="captureDurationSlider">Capture Duration (s): <span id="captureDurationValue">5</span>s</label>
                <input type="range" id="captureDurationSlider" min="1" max="60" value="5">
                <button id="startCaptureBtn">Start Capture</button>
            </div>
            <div id="debug-options">
                <input type="checkbox" id="upscaleCheckbox">
                <label for="upscaleCheckbox">Upscale 2x on Capture</label>
            </div>
            <div id="status">Ready</div>
        </div>
    </div>

<script>
    let config = {
        width: 1920,
        height: 1080,
        amplitude: 5,
        waveSpeed: 250,
        textToAnimate: 'New text',
        fontSize: 55,
        kerning: 10,
        fontFamily: 'Courier New',
        subtitleEnabled: false,
        subtitleText: 'Subtitle text',
        subtitleFontSize: 30,
        subtitleYOffset: 100,
        subtitleFadeInDelay: 1,
        subtitleFadeDuration: 1
    };

    const textInput = document.getElementById('textInput');
    const fontUpload = document.getElementById('fontUpload');
    const amplitudeInput = document.getElementById('amplitudeInput');
    const waveSpeedInput = document.getElementById('waveSpeedInput');
    const fontSizeInput = document.getElementById('fontSizeInput');
    const kerningInput = document.getElementById('kerningInput');
    const widthInput = document.getElementById('widthInput');
    const heightInput = document.getElementById('heightInput');
    const upscaleCheckbox = document.getElementById('upscaleCheckbox');
    const statusDiv = document.getElementById('status');
    const infoButton = document.getElementById('info-button');
    const infoModal = document.getElementById('info-modal');
    const closeModalButton = document.getElementById('close-modal-button');
    const startCaptureBtn = document.getElementById('startCaptureBtn');
    const captureDurationSlider = document.getElementById('captureDurationSlider');
    const captureDurationValue = document.getElementById('captureDurationValue');
    const subtitleCheckbox = document.getElementById('subtitleCheckbox');
    const subtitleSettings = document.getElementById('subtitle-settings');
    const subtitleTextInput = document.getElementById('subtitleTextInput');
    const subtitleFontSizeInput = document.getElementById('subtitleFontSizeInput');
    const subtitleYOffsetInput = document.getElementById('subtitleYOffsetInput');
    const subtitleFadeInDelayInput = document.getElementById('subtitleFadeInDelayInput');
    const subtitleFadeInDelayValue = document.getElementById('subtitleFadeInDelayValue');
    const subtitleFadeDurationInput = document.getElementById('subtitleFadeDurationInput');
    const subtitleFadeDurationValue = document.getElementById('subtitleFadeDurationValue');

    let canvas, ctx;
    let charObjs;
    let startTime = 0;
    let isCapturing = false;

    const updateFromEditor = () => {
        if (isCapturing) return;
        config.textToAnimate = textInput.value || ' ';
        config.amplitude = parseInt(amplitudeInput.value, 10);
        config.waveSpeed = parseInt(waveSpeedInput.value, 10);
        config.fontSize = parseInt(fontSizeInput.value, 10);
        config.kerning = parseInt(kerningInput.value, 10);
        config.width = parseInt(widthInput.value, 10);
        config.height = parseInt(heightInput.value, 10);
        config.subtitleEnabled = subtitleCheckbox.checked;
        config.subtitleText = subtitleTextInput.value;
        config.subtitleFontSize = parseInt(subtitleFontSizeInput.value, 10);
        config.subtitleYOffset = parseInt(subtitleYOffsetInput.value, 10);
        config.subtitleFadeInDelay = parseFloat(subtitleFadeInDelayInput.value);
        config.subtitleFadeDuration = parseFloat(subtitleFadeDurationInput.value);

        subtitleSettings.classList.toggle('hidden', !config.subtitleEnabled);
        
        canvas.width = config.width;
        canvas.height = config.height;
        initText(config);
    };

    const initText = (currentConfig) => {
        const fontStyle = `bold ${currentConfig.fontSize}px ${currentConfig.fontFamily}`;
        ctx.font = fontStyle;
        ctx.textBaseline = 'middle';
        const totalTextWidth = ctx.measureText(currentConfig.textToAnimate).width + (currentConfig.textToAnimate.length > 1 ? (currentConfig.textToAnimate.length - 1) * currentConfig.kerning : 0);
        let currentPosition = (currentConfig.width - totalTextWidth) / 2;
        charObjs = currentConfig.textToAnimate.split('').map((char, index) => {
            const charWidth = ctx.measureText(char).width;
            const charObj = { char, width: charWidth, position: currentPosition, index: index };
            currentPosition += charWidth + currentConfig.kerning;
            return charObj;
        });
    };
    
    const drawFrameAtTime = (time, currentConfig, disableAntiAliasing = false) => {
        ctx.imageSmoothingEnabled = !disableAntiAliasing;
        ctx.clearRect(0, 0, currentConfig.width, currentConfig.height);
        ctx.fillStyle = 'black';
        ctx.fillRect(0,0, currentConfig.width, currentConfig.height);

        let fontStyle = `bold ${currentConfig.fontSize}px ${currentConfig.fontFamily}`;
        ctx.font = fontStyle;
        ctx.textBaseline = 'middle';

        charObjs.forEach((charObj) => {
            const y = Math.sin(time / currentConfig.waveSpeed + charObj.index / 2.5) * currentConfig.amplitude;
            const normalizedY = (y + currentConfig.amplitude) / (currentConfig.amplitude * 2);
            const hue = normalizedY * 240;
            ctx.fillStyle = `hsl(${hue}, 100%, 60%)`;
            ctx.fillText(charObj.char, charObj.position, currentConfig.height / 2 + y);
        });
        
        if (currentConfig.subtitleEnabled && time >= currentConfig.subtitleFadeInDelay * 1000) {
            const fadeInStartTime = currentConfig.subtitleFadeInDelay * 1000;
            const fadeDuration = currentConfig.subtitleFadeDuration * 1000;
            const timeSinceFadeStart = time - fadeInStartTime;
            
            let opacity = 1;
            if (fadeDuration > 0 && timeSinceFadeStart < fadeDuration) {
                opacity = timeSinceFadeStart / fadeDuration;
            }
            
            ctx.globalAlpha = opacity;
            fontStyle = `bold ${currentConfig.subtitleFontSize}px ${currentConfig.fontFamily}`;
            ctx.font = fontStyle;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText(currentConfig.subtitleText, currentConfig.width / 2, currentConfig.height / 2 + currentConfig.subtitleYOffset);
            
            ctx.globalAlpha = 1; // Reset alpha
            ctx.textAlign = 'left'; // Reset alignment
        }
    }

    const animate = () => {
        if (!isCapturing) {
           drawFrameAtTime(Date.now() - startTime, config, false);
        }
        requestAnimationFrame(animate);
    };
    
    const handleFontUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const fontFace = new FontFace('user-uploaded-font', event.target.result);
            document.fonts.add(fontFace);
            fontFace.load().then(() => {
                config.fontFamily = 'user-uploaded-font';
                updateFromEditor();
            }).catch(console.error);
        };
        reader.readAsArrayBuffer(file);
    };

    const startCapture = async () => {
        const durationSeconds = parseInt(captureDurationSlider.value, 10);
        if (isCapturing) return;
        isCapturing = true;
        startCaptureBtn.disabled = true;
        
        const originalConfig = { ...config };
        let captureConfig = { ...config };
        const scaleFactor = upscaleCheckbox.checked ? 2 : 1;
        
        if (scaleFactor > 1) {
            statusDiv.textContent = 'Scaling config for capture...';
            ['width', 'height', 'fontSize', 'amplitude', 'kerning', 'subtitleFontSize', 'subtitleYOffset'].forEach(key => {
                captureConfig[key] *= scaleFactor;
            });
            canvas.width = captureConfig.width;
            canvas.height = captureConfig.height;
            initText(captureConfig);
        }

        const frameRate = 120;
        const totalFrames = durationSeconds * frameRate;
        const zip = new JSZip();

        statusDiv.textContent = 'Starting capture...';

        try {
            for (let i = 0; i < totalFrames; i++) {
                const time = i * (1000 / frameRate);
                drawFrameAtTime(time, captureConfig, true); 
                
                const frameName = `frame_${String(i).padStart(5, '0')}.png`;
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                zip.file(frameName, blob);

                statusDiv.textContent = `Captured frame ${i + 1} of ${totalFrames}`;
                if (i % 10 === 0) await new Promise(resolve => setTimeout(resolve, 0));
            }

            statusDiv.textContent = 'Creating FFmpeg batch file...';
            const batContent = `@echo off\r\ncd /d "%~dp0"\r\nffmpeg -framerate ${frameRate} -i frame_%%05d.png -c:v libx264 -pix_fmt yuv420p -r ${frameRate} output.mp4\r\npause`;
            zip.file('create_video.bat', batContent);

            statusDiv.textContent = 'Generating ZIP file...';
            const zipBlob = await zip.generateAsync({type: 'blob'});

            statusDiv.textContent = 'Downloading...';
            const link = document.createElement('a');
            link.href = URL.createObjectURL(zipBlob);
            link.download = `wavy_text_capture.zip`;
            link.click();
            URL.revokeObjectURL(link.href);
            
        } finally {
            if (scaleFactor > 1) {
                statusDiv.textContent = 'Restoring preview...';
                canvas.width = originalConfig.width;
                canvas.height = originalConfig.height;
                initText(originalConfig);
            }
            statusDiv.textContent = 'Ready';
            isCapturing = false;
            startCaptureBtn.disabled = false;
        }
    };

    const start = () => {
        const mainContainer = document.getElementById('main-container');
        canvas = document.createElement('canvas');
        mainContainer.appendChild(canvas);
        ctx = canvas.getContext('2d');
        updateFromEditor();

        document.querySelectorAll('#editor input').forEach(input => input.addEventListener('input', updateFromEditor));
        fontUpload.addEventListener('change', handleFontUpload);
        infoButton.addEventListener('click', () => infoModal.classList.remove('hidden'));
        closeModalButton.addEventListener('click', () => infoModal.classList.add('hidden'));
        startCaptureBtn.addEventListener('click', startCapture);
        captureDurationSlider.addEventListener('input', () => captureDurationValue.textContent = captureDurationSlider.value);
        subtitleFadeInDelayInput.addEventListener('input', () => subtitleFadeInDelayValue.textContent = `${parseFloat(subtitleFadeInDelayInput.value).toFixed(1)}s`);
        subtitleFadeDurationInput.addEventListener('input', () => subtitleFadeDurationValue.textContent = `${parseFloat(subtitleFadeDurationInput.value).toFixed(1)}s`);
        
        startTime = Date.now();
        animate();
    };

    start();
</script>
</body>
</html>
